# Обоснование принятых решений:
### Использование библиотек:
Все используемые технологии и библиотеки можно найти в файле [Dependencies.kt](https://github.com/zzzondy/lifestylehub/blob/master/buildSrc/src/main/java/Dependencies.kt)

1. Jetpack Compose был выбран как один из наиболее рекомендуемых подходов от Google. Наше приложение планирует развиваться, мы не хотим отставать от времени, поэтому решили сразу писать на самых современных технологиях. В будущем переписывать проект с View на Compose будет сложнее, дольше и дороже. 
2. Многие библиотеки Android Jetpack поддерживают Kotlin Coroutines, поэтому их использование в проекте предоставляет удобства по сравнению с другими подходами. Кроме этого, библиотека является легкой, что уменьшает размер приложения. Structured concurrency упрощает работу с асинхронностью.
3. Dagger был выбран как наиболее подходящая библиотека для внедрения зависимостей в многомодульных проектах. Другие библиотеки не предоставляют таких же возможностей и кастомизаций как Dagger.
4. У Room есть огромная поддержка от Google и сообщества разработчиков. Его использование упрощает и ускоряет работу над базами данных. [SqlCipher](https://github.com/sqlcipher/android-database-sqlcipher) использован как готовое решение для шифрования. Имеет совместимость c Room, поэтому и был выбран.
5. Retrofit + OkHttp был выбран как один из самый зарекомендовавших себя библиотек в сообществе. По ним есть много ответов на вопросы.
### Архитектура:
Многомодульная архитектура была выбрана для упрощения тестирования, поддержки, разделения ответственности, читаемости. Наш проект обещает расти, растет и количество кода, поэтому его нужно разделять на логические блоки. Кроме этого, использование такого подхода в разы увеличивает скорость сборки приложения.
В качестве паттерна для отображения пользовательского интерфейса был выбран Model View Intent (в нашем прилолжении + ViewModel), потому что этот подход предоставляет single source of truth. Это упрощает работу с состоянием UI, тестирование логики отображения. Также этот паттерн хорошо совместим с Jetpack Compose.
Все фичи разделены на data, domain и presentation модули, что разделяет ответственность на логические участки кода. Это помогает при тестировании и поддержке.
# Документация:
Проект представляет собой app, common и features модули. Фичей в проекте считается одна вкладка в bottom navigation bar. Features-модули не зависят от app модуля, они реализуют собственную навигацию, описанную с помощью интерфейсов [FeatureNavigationApi](https://github.com/zzzondy/lifestylehub/blob/master/common/navigation/src/main/java/com/common/navigation/FeatureNavigationApi.kt) и [BottomBarItem](https://github.com/zzzondy/lifestylehub/blob/master/common/navigation/src/main/java/com/common/navigation/BottomBarItem.kt). С помощью Dagger реализации этих интерфейсов попадают в set, что позволяет удобно регистрировать навигацию фич в главный граф. ([AppNavGraph](https://github.com/zzzondy/lifestylehub/blob/master/app/src/main/java/com/lifestylehub/navigation/AppNavGraph.kt))
Исключением являеются общая фича PlaceDetails. Этот экран используется в нескольких местах в приложении, поэтому она была вынесена как общая. Эта фича не реализует собственную навигацию.
Логика фич планирования и авторизации вынесена, потому что она потенциально может использоваться во многих местах в приложении.
Каждый модуль создает собственные, нужные только ему зависимости с помощью Subcomponents, Scopes из Dagger. Кроме этого, каждый экран фичи создает свои зависимости. Они "живут" пока "живет" экран.
# Реализованные фичи:
### Главная страница:
Текущая погода, случайные советы и список популярных мест поблизости с пагинацией. Для каждого из элементов реализованы состояния ошибки, загрузки (skeleton-loading) и контента. Кроме этого, на этом экране есть pull to refresh механизм. Обработка запроса разрешений происходит по следующему сценарию: если пользователь отказался давать разрешение в первый раз, будет показываться диалог с просьбой о даче разрешения при попытке получить доступ к контенту, доступному лишь с использованием разрешений; если пользователь отказался и во второй раз, будет предложено открыть настройки и выдать разрешение вручную.

<img src="/screenshots/главная.png" alt="drawing" style="width:300px;"/>

### Экран деталей места:
Отображение состояний (загрузка, контент, ошибка). Если api не прислало другие фотографии места кроме лучшего, они не показываются. С этого экрана можно попасть на планирование дела, если на этот экран не попали из фичи планировщика. 

<img src="/screenshots/детали_места.png" alt="drawing" style="width:300px;"/>

### Экран добавления плана (из экрана деталей):
Возможность ввести название плана, выбрать дату. При нажатии на пустое место при редактировании поля, клавиатура закрывается.

<img src="/screenshots/планирование_из_деталей.png" alt="drawing" style="width:300px;"/>

### Экран мой досуг:
Предполагается, что в будущем возможна интеграция с бэкендом. Состояния пустого списка задач и контента. Дело можно удалить с помощью свайпа влево. Если дело заключается в планировании посещения какого-то места, то можно попасть на экран деталей места.

<img src="/screenshots/мой_досуг.png" alt="drawing" style="width:300px;"/>

### Экран планирования дела:
Все, что и в выше описанном экране. Плюс можно добавить заметку.

<img src="/screenshots/планирование.png" alt="drawing" style="width:300px;"/>

### Профиль пользователя:
Возможность войти или зарегестрироваться. Если пользователь авторизован, то он может выйти из аккаунта. Текущий пользователь сохраняется в памяти приложения, поэтому при его выключении, пользователю не нужно снова входить в аккаунт.

<img src="/screenshots/планирование.png" alt="drawing" style="width:300px;"/>

### Экраны войти и зарегистрироваться:

<img src="/screenshots/войти.png" alt="drawing" style="width:300px;"/>
<img src="/screenshots/зарегистрироваться.png" alt="drawing" style="width:300px;"/>
